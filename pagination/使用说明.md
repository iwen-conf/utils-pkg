# pagination 使用说明

该包提供两种完全独立的分页方案，帮助你在不同场景下快速实现分页功能。

## 支持的分页方案

### 方案 1️⃣：游标分页（Cursor-based Pagination）
**适用场景**：
- ✅ 数据实时变化频繁（如社交动态流、聊天记录）
- ✅ 只需前进/后退，无需跳页
- ✅ 需要防止数据重复或遗漏
- ✅ 大数据量深度翻页性能敏感

**特性**：
- 基础请求体 `CursorRequest`（`cursor` + `limit`）与归一化方法
- 基础响应体 `CursorResponse`（仅包含 `next_cursor`、`prev_cursor`、`has_more`），数据列表由业务层返回
- 可插拔游标编解码器：`Base64JSONCodec`（JSON+Base64 URL 安全）与 `HMACCodec`（带签名防篡改）
- 哨兵错误（Sentinel Errors）支持 `errors.Is` 判断错误类型

### 方案 2️⃣：偏移量分页（Offset-based Pagination）
**适用场景**：
- ✅ 数据相对稳定（如商品列表、文章归档）
- ✅ 需要显示总记录数
- ✅ 用户需要直接跳转到指定位置
- ✅ 偏移量较小（< 10,000 条）

**特性**：
- 基础请求体 `OffsetRequest`（`offset` + `limit`）与归一化方法
- 基础响应体 `OffsetResponse`（`offset`、`limit`、`total`、`has_more`）
- 提供辅助方法：`GetNextOffset()`、`GetPrevOffset()`、`IsFirstPage()`、`IsLastPage()`
- 自动计算分页元信息

---

**包路径**：`github.com/iwen-conf/utils-pkg/pagination`

## 安装与导入

```go
import "github.com/iwen-conf/utils-pkg/pagination"
```

## 一、游标分页（Cursor-based）

### 请求与响应结构

- **`CursorRequest`**
  - `cursor`: 上一页返回的游标（不透明字符串）
  - `limit`: 本页期望返回条数。调用 `Normalize()` 自动应用默认与上限

- **`CursorResponse`**
  - `next_cursor`: 下一页游标（可为空）
  - `prev_cursor`: 上一页游标（按需生成，可为空）
  - `has_more`: 是否还有更多数据

**默认约束**：`DefaultLimit=20`，`MaxLimit=100`，`MinLimit=1`，`RecommendedHMACKeySize=32`。

## 游标编解码器

- `Base64JSONCodec`：将载荷（如最后一条记录的关键字段）以 JSON 编码，再进行 Base64(URL) 编码。
- `HMACCodec`：在以上基础上增加 HMAC-SHA256 签名，格式：`v1.{payload}.{sig}`，防篡改。**生产环境强烈建议使用**。

### 示例（生成与解析游标）

```go
// 定义你的游标载荷结构（示例：按 ID 游标）
type idCursor struct { LastID int64 `json:"last_id"` }

// 创建 HMAC 编解码器（推荐密钥长度 >= 32 字节）
codec, err := pagination.NewHMACCodec([]byte(os.Getenv("CURSOR_HMAC_KEY")))
if err != nil {
    // 处理错误：可能是密钥为空或过短
    if errors.Is(err, pagination.ErrEmptyHMACKey) {
        log.Fatal("HMAC key is required")
    }
    if errors.Is(err, pagination.ErrHMACKeyTooShort) {
        log.Warn("HMAC key is too short, recommend at least 32 bytes")
    }
}

// 生成下一页游标
cstr, err := codec.Encode(idCursor{LastID: last.ID})
if err != nil { /* handle error */ }

// 解析请求中的游标
var cur idCursor
if req.Cursor != "" {
    if err := codec.Decode(req.Cursor, &cur); err != nil {
        // 使用哨兵错误判断错误类型
        if errors.Is(err, pagination.ErrEmptyCursor) {
            // 游标为空
        } else if errors.Is(err, pagination.ErrInvalidCursorFormat) {
            // 游标格式无效（Base64 或 JSON 解析失败）
        } else if errors.Is(err, pagination.ErrInvalidSignature) {
            // 游标签名校验失败（可能被篡改）
        }
    }
}
```

## 哨兵错误（Sentinel Errors）

包导出以下错误常量，可用 `errors.Is()` 判断：

- `ErrEmptyCursor` - 游标为空
- `ErrInvalidCursorFormat` - 游标格式无效（Base64 或 JSON 解析失败）
- `ErrInvalidSignature` - 游标签名校验失败（可能被篡改）
- `ErrEmptyHMACKey` - HMAC 密钥为空（构造 `HMACCodec` 时）
- `ErrHMACKeyTooShort` - HMAC 密钥长度不足（警告，仍可使用）

## 集成步骤（建议实践）

1. **绑定请求**
   - 将查询参数或 JSON 请求体绑定到 `CursorRequest`
   - 调用 `Normalize()` 归一化 `limit`

2. **执行查询**
   - 根据游标载荷（如 `LastID`、`LastTime`）进行条件查询，拉取 `limit + 1` 条用于判断是否还有下一页
   
3. **组装响应**
   - 若查询结果超过 `limit` 条，说明存在下一页：
     - `has_more = true`，裁剪结果为 `limit` 条
     - 用本页最后一条记录生成 `next_cursor`
   - 如需上一页游标，可用本页第一条记录构建 `prev_cursor`（按需实现）
   - 返回业务数据与 `CursorResponse` 元信息

---

## 二、偏移量分页（Offset-based）

### 请求与响应结构

- **`OffsetRequest`**
  - `offset`: 跳过的记录数（从 0 开始）
  - `limit`: 本页希望返回的最大记录数
  - 提供方法：`Normalize()`、`GetNextOffset()`、`GetPrevOffset()`、`IsFirstPage()`、`IsLastPage(total)`

- **`OffsetResponse`**
  - `offset`: 当前偏移量
  - `limit`: 每页条数
  - `total`: 总记录数
  - `has_more`: 是否还有更多数据
  - 提供方法：`Calculate(req, total, actualCount)`

**默认约束**：与游标分页共享 `DefaultLimit=20`，`MaxLimit=100`，`MinLimit=1`。

### 使用示例

```go
// 1. 绑定请求并归一化
req := pagination.OffsetRequest{
    Offset: 20,  // 从第 21 条开始
    Limit:  10,  // 每页 10 条
}
req.Normalize() // 自动应用默认值与上限

// 2. 执行查询（需要先查询总数）
var total int64
db.Model(&Product{}).Count(&total)

var products []Product
db.Offset(req.Offset).Limit(req.Limit).Find(&products)

// 3. 组装响应
resp := pagination.OffsetResponse{}
resp.Calculate(req, total, len(products))

// 4. 返回给前端
return gin.H{
    "data":       products,
    "pagination": resp,
    // 可选：提供导航链接
    "next_offset": req.GetNextOffset(),
    "prev_offset": req.GetPrevOffset(),
}
```

### 辅助方法说明

- **`GetNextOffset()`**：计算下一页的偏移量 = `offset + limit`
- **`GetPrevOffset()`**：计算上一页的偏移量 = `max(0, offset - limit)`
- **`IsFirstPage()`**：判断是否为第一页（`offset == 0`）
- **`IsLastPage(total)`**：判断是否为最后一页（`offset + limit >= total`）

### 集成步骤

1. **绑定请求**
   - 将查询参数绑定到 `OffsetRequest`，调用 `Normalize()` 归一化

2. **查询总数**
   - 先执行 `COUNT(*)` 获取符合条件的总记录数

3. **执行分页查询**
   - 使用 `OFFSET` 和 `LIMIT` 拉取当前页数据

4. **组装响应**
   - 调用 `resp.Calculate(req, total, actualCount)` 自动计算分页元信息

---

## 注意事项

### 游标分页
- 不透明游标不应泄露内部结构；如需可验证性，使用 `HMACCodec` 并妥善保管密钥（建议长度 ≥ 32 字节，来源环境变量）。
- JSON 字段命名当前为蛇形（`next_cursor`、`has_more`）。如需改为驼峰，可在工程中使用自定义序列化策略或本包新增可选结构体。

### 偏移量分页
- 大偏移量（> 10,000）性能较差，建议使用游标分页。
- 数据实时变化时可能导致重复或遗漏，适合相对稳定的数据集。
- 每次请求都需要查询总数，适当使用缓存可提升性能。

## 两种方案对比

| 特性 | 游标分页 | 偏移量分页 |
|------|---------|-----------|
| **性能** | 深度翻页性能稳定 | 大偏移量性能下降 |
| **数据一致性** | 无重复/遗漏 | 可能重复/遗漏 |
| **跳页能力** | 不支持 | 支持任意跳转 |
| **总数显示** | 不支持 | 支持 |
| **实现复杂度** | 中等（需编码游标） | 简单 |
| **适用场景** | 实时流、聊天记录 | 商品列表、文章归档 |

## 版本与兼容

- 默认使用 Go 1.20+ 均可（本包未使用低版本不支持的特性）。
- 外部无破坏性依赖，直接引入即可。
