# 验证码生成器使用说明

## 简介

验证码生成器是一个专门用于生成安全数字验证码的Go语言工具包。它严格遵循安全最佳实践，使用密码学安全伪随机数生成器(CSPRNG)确保验证码的不可预测性，适用于用户身份验证、防止自动化攻击等安全场景。

## 主要特性

- **密码学安全**: 使用`crypto/rand`包确保真正的随机性
- **纯数字字符集**: 避免用户输入混淆（如O和0，l和I和1等）
- **推荐长度**: 默认6位，平衡安全性和用户体验
- **灵活配置**: 支持4-12位长度的验证码
- **简单验证**: 提供便捷的验证码匹配功能
- **格式检查**: 内置验证码格式验证
- **高性能**: 优化的字符串构建和内存使用
- **自定义字符集**: 支持自定义字符集（不推荐）

## 安全设计原则

### 1. 长度选择
- **推荐6位**: 提供100万种组合(`10^6`)，足以抵御在线暴力破解
- **最小4位**: 1万种组合，适用于低安全要求场景
- **最大12位**: 1万亿种组合，适用于极高安全要求

### 2. 字符集设计
- **纯数字**: 避免字符混淆，提升用户体验
- **移动友好**: 用户可直接调出数字键盘输入

### 3. 随机性保证
- **CSPRNG**: 使用`crypto/rand`而非`math/rand`
- **独立生成**: 每位数字都独立随机生成
- **无模式**: 不存在可预测的生成模式

## 安装

```bash
go get github.com/iwen-conf/utils-pkg
```

## 快速开始

### 基本用法

```go
package main

import (
    "fmt"
    "github.com/iwen-conf/utils-pkg/captcha"
)

func main() {
    // 生成推荐的6位验证码
    code, err := captcha.Generate6()
    if err != nil {
        panic(err)
    }
    fmt.Printf("验证码: %s\n", code)
    
    // 生成自定义长度的验证码
    code8, err := captcha.Generate(8)
    if err != nil {
        panic(err)
    }
    fmt.Printf("8位验证码: %s\n", code8)
    
    // 验证验证码
    userInput := "123456" // 用户输入
    if captcha.Validate(userInput, code) {
        fmt.Println("验证码正确")
    } else {
        fmt.Println("验证码错误")
    }
}
```

## API 参考

### 核心函数

#### Generate(length int) (string, error)
生成指定长度的数字验证码。

**参数:**
- `length`: 验证码长度，必须在4-12位之间

**返回值:**
- `string`: 生成的验证码
- `error`: 错误信息

**示例:**
```go
code, err := captcha.Generate(6)
if err != nil {
    log.Fatal(err)
}
fmt.Println("验证码:", code) // 输出: 验证码: 123456
```

#### Generate6() (string, error)
生成推荐的6位验证码，这是最常用的函数。

**示例:**
```go
code, err := captcha.Generate6()
if err != nil {
    log.Fatal(err)
}
fmt.Println("6位验证码:", code)
```

#### Generate4() (string, error)
生成4位验证码，适用于安全要求较低的场景。

#### Generate8() (string, error)
生成8位验证码，适用于高安全要求的场景。

#### Validate(input, expected string) bool
验证用户输入的验证码是否正确。

**参数:**
- `input`: 用户输入的验证码
- `expected`: 期望的验证码

**返回值:**
- `bool`: 验证结果

**特性:**
- 自动去除输入两端的空白字符
- 大小写敏感（数字验证码不涉及大小写）

**示例:**
```go
isValid := captcha.Validate(" 123456 ", "123456")
fmt.Println("验证结果:", isValid) // 输出: 验证结果: true
```

### 辅助函数

#### IsValidFormat(code string) bool
检查字符串是否为有效的验证码格式。

**验证规则:**
- 长度在4-12位之间
- 只包含数字字符

**示例:**
```go
fmt.Println(captcha.IsValidFormat("123456"))  // true
fmt.Println(captcha.IsValidFormat("12a456"))  // false
fmt.Println(captcha.IsValidFormat("123"))     // false (太短)
```

#### GenerateWithCustomCharset(length int, charset string) (string, error)
使用自定义字符集生成验证码。

**注意:** 虽然提供了此功能，但强烈建议使用默认的数字字符集。

**示例:**
```go
// 使用十六进制字符集
code, err := captcha.GenerateWithCustomCharset(6, "0123456789ABCDEF")
if err != nil {
    log.Fatal(err)
}
fmt.Println("十六进制验证码:", code)
```

## 实际应用示例

### Web应用中的验证码

```go
package main

import (
    "encoding/json"
    "net/http"
    "time"
    
    "github.com/iwen-conf/utils-pkg/captcha"
)

// 验证码存储（实际应用中应使用Redis等）
var captchaStore = make(map[string]CaptchaInfo)

type CaptchaInfo struct {
    Code      string
    ExpiresAt time.Time
}

type CaptchaResponse struct {
    Success bool   `json:"success"`
    Message string `json:"message"`
    Code    string `json:"code,omitempty"`
}

// 生成验证码接口
func generateCaptchaHandler(w http.ResponseWriter, r *http.Request) {
    // 生成验证码
    code, err := captcha.Generate6()
    if err != nil {
        http.Error(w, "生成验证码失败", http.StatusInternalServerError)
        return
    }
    
    // 生成会话ID（实际应用中可能从session获取）
    sessionID := generateSessionID() // 自定义函数
    
    // 存储验证码（5分钟有效期）
    captchaStore[sessionID] = CaptchaInfo{
        Code:      code,
        ExpiresAt: time.Now().Add(5 * time.Minute),
    }
    
    // 返回响应
    response := CaptchaResponse{
        Success: true,
        Message: "验证码生成成功",
        Code:    code, // 实际应用中不应返回验证码，而是通过短信/邮件发送
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// 验证验证码接口
func verifyCaptchaHandler(w http.ResponseWriter, r *http.Request) {
    sessionID := r.Header.Get("Session-ID")
    userCode := r.FormValue("code")
    
    // 检查验证码是否存在
    info, exists := captchaStore[sessionID]
    if !exists {
        response := CaptchaResponse{
            Success: false,
            Message: "验证码不存在或已过期",
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
        return
    }
    
    // 检查是否过期
    if time.Now().After(info.ExpiresAt) {
        delete(captchaStore, sessionID)
        response := CaptchaResponse{
            Success: false,
            Message: "验证码已过期",
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
        return
    }
    
    // 验证验证码
    if captcha.Validate(userCode, info.Code) {
        delete(captchaStore, sessionID) // 验证成功后删除
        response := CaptchaResponse{
            Success: true,
            Message: "验证码正确",
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
    } else {
        response := CaptchaResponse{
            Success: false,
            Message: "验证码错误",
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
    }
}

func generateSessionID() string {
    // 实现会话ID生成逻辑
    id, _ := captcha.Generate(16)
    return id
}

func main() {
    http.HandleFunc("/captcha/generate", generateCaptchaHandler)
    http.HandleFunc("/captcha/verify", verifyCaptchaHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### 短信验证码服务

```go
package main

import (
    "fmt"
    "log"
    "time"
    
    "github.com/iwen-conf/utils-pkg/captcha"
)

type SMSService struct {
    // SMS服务配置
}

func (s *SMSService) SendVerificationCode(phoneNumber string) error {
    // 生成6位验证码
    code, err := captcha.Generate6()
    if err != nil {
        return fmt.Errorf("生成验证码失败: %v", err)
    }
    
    // 存储验证码（实际应用中存储到Redis等）
    storeVerificationCode(phoneNumber, code, 5*time.Minute)
    
    // 发送短信
    message := fmt.Sprintf("您的验证码是: %s，5分钟内有效。", code)
    return s.sendSMS(phoneNumber, message)
}

func (s *SMSService) VerifyCode(phoneNumber, userCode string) bool {
    storedCode := getStoredVerificationCode(phoneNumber)
    if storedCode == "" {
        return false
    }
    
    // 验证验证码
    if captcha.Validate(userCode, storedCode) {
        // 验证成功后删除存储的验证码
        deleteVerificationCode(phoneNumber)
        return true
    }
    
    return false
}

func (s *SMSService) sendSMS(phoneNumber, message string) error {
    // 实际的短信发送逻辑
    log.Printf("发送短信到 %s: %s", phoneNumber, message)
    return nil
}

// 存储相关函数（示例实现）
func storeVerificationCode(phone, code string, duration time.Duration) {
    // 实际应用中使用Redis等
}

func getStoredVerificationCode(phone string) string {
    // 实际应用中从Redis等获取
    return ""
}

func deleteVerificationCode(phone string) {
    // 实际应用中从Redis等删除
}
```

## 最佳实践

### 1. 安全建议

```go
// ✅ 推荐：使用默认的6位数字验证码
code, err := captcha.Generate6()

// ✅ 推荐：设置合理的过期时间（5-10分钟）
expiresAt := time.Now().Add(5 * time.Minute)

// ✅ 推荐：限制尝试次数
const maxAttempts = 3

// ❌ 不推荐：使用过短的验证码
code, err := captcha.Generate(3) // 太短，不安全

// ❌ 不推荐：使用包含易混淆字符的自定义字符集
code, err := captcha.GenerateWithCustomCharset(6, "0O1lI") // 易混淆
```

### 2. 性能优化

```go
// ✅ 推荐：批量生成验证码
func generateBatch(count int) ([]string, error) {
    codes := make([]string, 0, count)
    for i := 0; i < count; i++ {
        code, err := captcha.Generate6()
        if err != nil {
            return nil, err
        }
        codes = append(codes, code)
    }
    return codes, nil
}

// ✅ 推荐：使用对象池减少内存分配（如果需要）
var codePool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 6)
    },
}
```

### 3. 错误处理

```go
// ✅ 推荐：适当的错误处理
code, err := captcha.Generate6()
if err != nil {
    log.Printf("生成验证码失败: %v", err)
    return errors.New("系统繁忙，请稍后重试")
}

// ✅ 推荐：验证输入格式
if !captcha.IsValidFormat(userInput) {
    return errors.New("验证码格式不正确")
}
```

## 常见问题

### Q: 为什么只支持数字验证码？
A: 数字验证码避免了字符混淆问题（如O和0，l和I和1），提供最佳的用户体验，特别是在移动设备上。

### Q: 6位验证码的安全性如何？
A: 6位数字验证码提供100万种组合，配合适当的过期时间和尝试次数限制，足以抵御在线暴力破解攻击。

### Q: 可以使用字母和数字混合吗？
A: 技术上可以通过`GenerateWithCustomCharset`实现，但不推荐，因为会增加用户输入错误的概率。

### Q: 如何防止验证码被暴力破解？
A: 建议实施以下措施：
- 设置合理的过期时间（5-10分钟）
- 限制尝试次数（通常3-5次）
- 实施IP限制和频率限制
- 验证成功后立即删除验证码

## 性能指标

在标准硬件上的性能表现：

- **生成速度**: 每秒可生成数十万个验证码
- **内存使用**: 每个验证码约占用几十字节内存
- **随机性**: 通过了标准的随机性测试
- **并发安全**: 支持高并发场景

## 更新日志

### v1.0.0
- 初始版本发布
- 支持4-12位数字验证码生成
- 使用crypto/rand确保安全随机性
- 提供验证和格式检查功能
- 完整的测试覆盖
