# ptr 包使用说明

[![Go Version](https://img.shields.io/badge/go-%3E%3D1.13-blue.svg)](https://golang.org/)
[![Coverage](https://img.shields.io/badge/coverage-100%25-brightgreen.svg)]()

## 目录

- [概述](#概述)
- [功能特性](#功能特性)
- [快速入门](#快速入门)
- [支持的函数](#支持的函数)
- [使用示例](#使用示例)
- [常见使用场景](#常见使用场景)
- [错误处理](#错误处理)
- [零值说明](#零值说明)
- [运行测试](#运行测试)
- [注意事项](#注意事项)
- [性能考虑](#性能考虑)
- [设计决策](#设计决策)
- [测试覆盖率](#测试覆盖率)
- [相关资源](#相关资源)

## 概述

`ptr` 包提供了一系列工具函数，用于创建和安全解引用各种类型的指针。这在需要传递指针参数但只有值的情况下，或需要安全地从指针获取值时非常有用。

## 功能特性

- 支持所有基本数据类型的指针创建
- 支持所有基本数据类型的安全解引用
- 明确的类型定义，无泛型
- 完善的错误处理机制
- 简洁易用的API设计
- 完整的测试覆盖（100%覆盖率）
- 良好的文档注释
- 零内存分配，高性能

## 快速入门

### 安装

```bash
go get github.com/iwen-conf/utils-pkg/ptr
```

### 创建指针

```go
import "github.com/iwen-conf/utils-pkg/ptr"

// 创建各种类型的指针
s := ptr.String("hello")      // *string
i := ptr.Int(42)              // *int
b := ptr.Bool(true)           // *bool
f := ptr.Float64(3.14)        // *float64
```

### 安全解引用

```go
import "github.com/iwen-conf/utils-pkg/ptr"

// 从指针安全地获取值
name := "Alice"
val, err := ptr.ValueString(&name)
if err != nil {
    // 处理错误（指针为 nil）
}
fmt.Println(val) // 输出: Alice

// 处理 nil 指针
var nilPtr *string
val, err = ptr.ValueString(nilPtr)
if err == ptr.ErrNilPointer {
    val = "默认值"  // 使用默认值
}
```

### 完整示例

```go
package main

import (
    "fmt"
    "github.com/iwen-conf/utils-pkg/ptr"
)

type User struct {
    Name  string
    Email *string
    Age   *int
}

func main() {
    // 创建用户，使用指针
    user := &User{
        Name:  "Alice",
        Email: ptr.String("alice@example.com"),
        Age:   ptr.Int(30),
    }
    
    // 安全获取可选字段的值
    email, err := ptr.ValueString(user.Email)
    if err != nil {
        email = "未提供"
    }
    
    age, err := ptr.ValueInt(user.Age)
    if err != nil {
        age = 0
    }
    
    fmt.Printf("用户: %s, 邮箱: %s, 年龄: %d\n", 
        user.Name, email, age)
}
```

## 支持的函数

### 1. 指针创建函数 (ptr.go)

#### 字符串类型
- `String(s string) *string` - 创建字符串指针

#### 整数类型
- `Int(i int) *int` - 创建int指针
- `Int8(i int8) *int8` - 创建int8指针
- `Int16(i int16) *int16` - 创建int16指针
- `Int32(i int32) *int32` - 创建int32指针
- `Int64(i int64) *int64` - 创建int64指针

#### 无符号整数类型
- `Uint(u uint) *uint` - 创建uint指针
- `Uint8(u uint8) *uint8` - 创建uint8指针
- `Uint16(u uint16) *uint16` - 创建uint16指针
- `Uint32(u uint32) *uint32` - 创建uint32指针
- `Uint64(u uint64) *uint64` - 创建uint64指针

#### 浮点数类型
- `Float32(f float32) *float32` - 创建float32指针
- `Float64(f float64) *float64` - 创建float64指针

#### 其他基本类型
- `Bool(b bool) *bool` - 创建bool指针
- `Byte(b byte) *byte` - 创建byte指针
- `Rune(r rune) *rune` - 创建rune指针

#### 复数类型
- `Complex64(c complex64) *complex64` - 创建complex64指针
- `Complex128(c complex128) *complex128` - 创建complex128指针

#### 时间类型
- `Time(t time.Time) *time.Time` - 创建time.Time指针
- `Duration(d time.Duration) *time.Duration` - 创建time.Duration指针

### 2. 安全解引用函数 (deref.go)

所有解引用函数都遵循相同的模式：如果指针为 `nil`，返回类型的零值和 `ErrNilPointer` 错误；否则返回解引用后的值和 `nil` 错误。

#### 字符串类型
- `ValueString(ptr *string) (string, error)` - 安全解引用字符串指针

#### 整数类型
- `ValueInt(ptr *int) (int, error)` - 安全解引用int指针
- `ValueInt8(ptr *int8) (int8, error)` - 安全解引用int8指针
- `ValueInt16(ptr *int16) (int16, error)` - 安全解引用int16指针
- `ValueInt32(ptr *int32) (int32, error)` - 安全解引用int32指针
- `ValueInt64(ptr *int64) (int64, error)` - 安全解引用int64指针

#### 无符号整数类型
- `ValueUint(ptr *uint) (uint, error)` - 安全解引用uint指针
- `ValueUint8(ptr *uint8) (uint8, error)` - 安全解引用uint8指针
- `ValueUint16(ptr *uint16) (uint16, error)` - 安全解引用uint16指针
- `ValueUint32(ptr *uint32) (uint32, error)` - 安全解引用uint32指针
- `ValueUint64(ptr *uint64) (uint64, error)` - 安全解引用uint64指针

#### 浮点数类型
- `ValueFloat32(ptr *float32) (float32, error)` - 安全解引用float32指针
- `ValueFloat64(ptr *float64) (float64, error)` - 安全解引用float64指针

#### 其他基本类型
- `ValueBool(ptr *bool) (bool, error)` - 安全解引用bool指针
- `ValueByte(ptr *byte) (byte, error)` - 安全解引用byte指针
- `ValueRune(ptr *rune) (rune, error)` - 安全解引用rune指针

#### 复数类型
- `ValueComplex64(ptr *complex64) (complex64, error)` - 安全解引用complex64指针
- `ValueComplex128(ptr *complex128) (complex128, error)` - 安全解引用complex128指针

#### 时间类型
- `ValueTime(ptr *time.Time) (time.Time, error)` - 安全解引用time.Time指针
- `ValueDuration(ptr *time.Duration) (time.Duration, error)` - 安全解引用time.Duration指针

## 使用示例

### 示例 1: 指针创建

```go
package main

import (
    "fmt"
    "time"
    "github.com/iwen-conf/utils-pkg/ptr"
)

func main() {
    // 基本类型指针创建
    strPtr := ptr.String("hello")
    intPtr := ptr.Int(42)
    boolPtr := ptr.Bool(true)
    
    fmt.Printf("String: %s\n", *strPtr)
    fmt.Printf("Int: %d\n", *intPtr)
    fmt.Printf("Bool: %t\n", *boolPtr)
    
    // 浮点数指针创建
    floatPtr := ptr.Float64(3.14)
    fmt.Printf("Float: %f\n", *floatPtr)
    
    // 时间指针创建
    now := time.Now()
    timePtr := ptr.Time(now)
    fmt.Printf("Time: %v\n", *timePtr)
}
```

### 示例 2: 安全解引用

```go
package main

import (
    "fmt"
    "log"
    "github.com/iwen-conf/utils-pkg/ptr"
)

func main() {
    // 非 nil 指针解引用
    s := "hello"
    val, err := ptr.ValueString(&s)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(val) // 输出: hello
    
    // nil 指针解引用
    var nilPtr *string
    val, err = ptr.ValueString(nilPtr)
    if err != nil {
        fmt.Printf("错误: %v\n", err) // 输出: 错误: 指针为空
        // 使用默认值
        val = "default"
    }
    fmt.Println(val) // 输出: default
    
    // 整数解引用
    i := 42
    intVal, err := ptr.ValueInt(&i)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(intVal) // 输出: 42
}
```

### 示例 3: 错误处理

```go
func GetUserAge(age *int) (int, error) {
    return ptr.ValueInt(age)
}

func main() {
    // 有效的年龄
    age := 30
    userAge, err := GetUserAge(&age)
    if err != nil {
        fmt.Println("使用默认年龄")
        userAge = 18
    }
    fmt.Printf("用户年龄: %d\n", userAge)
    
    // 空指针
    userAge, err = GetUserAge(nil)
    if err == ptr.ErrNilPointer {
        fmt.Println("年龄未提供，使用默认值")
        userAge = 18
    }
    fmt.Printf("用户年龄: %d\n", userAge)
}
```

## 常见使用场景

### 场景 1: API 参数传递（指针创建）

当 API 需要指针参数但只有值时：

```go
// 不使用ptr包
var age int = 25
user := &User{
    Name: "John",
    Age:  &age,  // 需要先声明变量
}

// 使用ptr包
user := &User{
    Name: "John",
    Age:  ptr.Int(25),  // 直接创建指针
}
```

### 场景 2: 结构体字段初始化

```go
type Config struct {
    Port     *int
    Host     *string
    Timeout  *time.Duration
    Debug    *bool
}

config := &Config{
    Port:    ptr.Int(8080),
    Host:    ptr.String("localhost"),
    Timeout: ptr.Duration(30 * time.Second),
    Debug:   ptr.Bool(true),
}
```

### 场景 3: 安全获取可选字段值（解引用）

```go
type User struct {
    Name  string
    Email *string  // 可选字段
    Age   *int     // 可选字段
}

func GetUserInfo(user *User) {
    fmt.Printf("姓名: %s\n", user.Name)
    
    // 安全获取 Email
    email, err := ptr.ValueString(user.Email)
    if err != nil {
        email = "未提供"
    }
    fmt.Printf("邮箱: %s\n", email)
    
    // 安全获取 Age
    age, err := ptr.ValueInt(user.Age)
    if err != nil {
        age = 0
    }
    fmt.Printf("年龄: %d\n", age)
}

// 使用
user1 := &User{
    Name:  "Alice",
    Email: ptr.String("alice@example.com"),
    Age:   ptr.Int(30),
}
GetUserInfo(user1)

user2 := &User{
    Name: "Bob",
    // Email 和 Age 为 nil
}
GetUserInfo(user2)
```

### 场景 4: 数据库可空字段处理

```go
type Product struct {
    ID          int
    Name        string
    Description *string  // 可为空
    Price       *float64 // 可为空
}

func DisplayProduct(p *Product) {
    fmt.Printf("ID: %d\n", p.ID)
    fmt.Printf("名称: %s\n", p.Name)
    
    // 安全获取描述
    desc, err := ptr.ValueString(p.Description)
    if err != nil {
        desc = "暂无描述"
    }
    fmt.Printf("描述: %s\n", desc)
    
    // 安全获取价格
    price, err := ptr.ValueFloat64(p.Price)
    if err != nil {
        fmt.Println("价格: 待定")
    } else {
        fmt.Printf("价格: %.2f\n", price)
    }
}
```

### 场景 5: API 响应处理

```go
type APIResponse struct {
    Status  int
    Message *string
    Data    *string
}

func ProcessResponse(resp *APIResponse) error {
    // 获取消息
    msg, err := ptr.ValueString(resp.Message)
    if err != nil {
        msg = "无消息"
    }
    fmt.Printf("消息: %s\n", msg)
    
    // 获取数据
    data, err := ptr.ValueString(resp.Data)
    if err != nil {
        return fmt.Errorf("响应中缺少数据")
    }
    
    fmt.Printf("数据: %s\n", data)
    return nil
}
```

### 场景 6: 配置文件解析

```go
type AppConfig struct {
    Host    *string
    Port    *int
    Timeout *time.Duration
}

func LoadConfig(cfg *AppConfig) {
    // 使用默认值或配置值
    host, _ := ptr.ValueString(cfg.Host)
    if host == "" {
        host = "localhost"
    }
    
    port, err := ptr.ValueInt(cfg.Port)
    if err != nil {
        port = 8080
    }
    
    timeout, err := ptr.ValueDuration(cfg.Timeout)
    if err != nil {
        timeout = 30 * time.Second
    }
    
    fmt.Printf("配置 - Host: %s, Port: %d, Timeout: %v\n", 
        host, port, timeout)
}
```

## 错误处理

所有 `Value*` 函数都返回 `ErrNilPointer` 错误（当指针为 nil 时）：

```go
var nilPtr *string
val, err := ptr.ValueString(nilPtr)
if err == ptr.ErrNilPointer {
    fmt.Println("指针为空，使用默认值")
    val = "default"
}
```

## 零值说明

当指针为 `nil` 时，`Value*` 函数会返回对应类型的零值：

| 类型 | 零值 |
|------|------|
| `string` | `""` (空字符串) |
| 所有整数类型 | `0` |
| 所有浮点数类型 | `0.0` |
| `bool` | `false` |
| `complex64/128` | `0+0i` |
| `time.Time` | `time.Time{}` (零时间) |
| `time.Duration` | `0` |

## 运行测试

```bash
# 运行所有测试
go test -v ./ptr

# 运行测试并查看覆盖率
go test -cover ./ptr

# 运行基准测试
go test -bench=. -benchmem ./ptr

# 运行竞态检测
go test -race ./ptr
```

## 注意事项

### 指针创建函数
1. 这些函数返回的指针指向传入值的副本，不是原始值
2. 适用于需要指针但只有值的场景
3. 对于大型结构体，建议直接使用指针而不是通过 ptr 包创建
4. 所有函数都是线程安全的

### 解引用函数
1. **不会 panic**：即使指针为 nil，也会返回零值和错误，而不是 panic
2. **类型安全**：每个类型都有专门的函数，在编译时进行类型检查
3. **错误检查**：始终检查返回的错误，根据业务需求决定如何处理 nil 指针
4. **性能优异**：零内存分配，适合高性能场景

## 性能考虑

### 指针创建
- 这些函数都是简单的指针创建操作，性能开销极小
- 适合在需要频繁创建指针的场景中使用

### 解引用操作
根据基准测试结果，所有解引用函数都具有极高的性能：

```
BenchmarkValueString-12    1000000000    0.2375 ns/op    0 B/op    0 allocs/op
BenchmarkValueInt-12       1000000000    0.2378 ns/op    0 B/op    0 allocs/op
BenchmarkValueBool-12      1000000000    0.2291 ns/op    0 B/op    0 allocs/op
BenchmarkValueFloat64-12   1000000000    0.2292 ns/op    0 B/op    0 allocs/op
BenchmarkValueTime-12      1000000000    0.2333 ns/op    0 B/op    0 allocs/op
```

- **零内存分配**：所有函数都不会产生堆内存分配
- **极低延迟**：每次调用仅需约 0.23 纳秒
- **适合热路径**：可以在性能关键路径中放心使用

## 设计决策

### 为什么不使用泛型？

1. **更好的类型安全**：每个类型都有明确的函数签名，在编译时进行严格的类型检查
2. **更好的兼容性**：支持 Go 1.18 之前的版本
3. **更清晰的 API**：函数名明确表示处理的类型，提高代码可读性
4. **更好的性能**：避免泛型可能带来的性能开销
5. **更好的文档**：每个函数都可以有针对性的文档说明

### 为什么使用错误返回而不是 panic？

1. **可恢复性**：调用者可以决定如何处理 nil 指针，而不是直接崩溃
2. **灵活性**：可以使用默认值、返回错误或其他策略
3. **符合 Go 惯例**：Go 推荐使用错误返回而不是 panic
4. **可测试性**：更容易编写测试用例

## 测试覆盖率

本包拥有 **100%** 的测试覆盖率，包括：

- 所有指针创建函数的单元测试
- 所有解引用函数的单元测试（nil 和非 nil 情况）
- 表格驱动测试
- 基准测试
- 竞态检测测试

## 相关资源

- 源代码：`ptr.go` - 指针创建函数
- 源代码：`deref.go` - 安全解引用函数
- 测试代码：`ptr_test.go` - 完整的单元测试
- 测试代码：`deref_test.go` - 基准测试和表格驱动测试
