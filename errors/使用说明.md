# Errors Package - 使用说明

这是一个功能强大的 Go 错误处理包，提供了结构化错误处理、错误链、验证、工具函数等功能。

## 功能特性

- **结构化错误**: 支持错误码、消息、详情、时间戳和上下文信息
- **错误链**: 支持错误包装和链式追踪
- **预定义错误类型**: 提供常用的错误类型和严重级别
- **构建器模式**: 流畅的错误构建接口
- **验证功能**: 内置数据验证器
- **工具函数**: 丰富的错误处理工具
- **格式化输出**: 支持多种格式的错误输出

## 包结构

```
errors/
├── errors.go           # 核心 Error 结构体和基本方法
├── error_types.go      # 预定义错误类型和常量
├── error_builder.go    # 错误构建器和工厂函数
├── error_utils.go      # 错误处理工具函数
├── error_validation.go # 验证错误和验证器
├── examples_test.go    # 使用示例
└── 使用说明.md         # 本文档
```

## 快速开始

### 基本用法

```go
package main

import (
    "fmt"
    "github.com/iwen-conf/utils-pkg/errors"
)

func main() {
    // 创建简单错误
    err := errors.New("USER_NOT_FOUND", "用户未找到")
    fmt.Println(err.Error()) // [USER_NOT_FOUND] 用户未找到

    // 创建带详情的错误
    err = errors.NewWithDetails("INVALID_INPUT", "输入无效", "邮箱格式不正确")
    fmt.Println(err.Error()) // [INVALID_INPUT] 输入无效: 邮箱格式不正确
}
```

### 添加上下文信息

```go
err := errors.New("DATABASE_ERROR", "数据库操作失败")
err.WithContext("user_id", "12345")
err.WithContext("operation", "create_user")
err.WithContext("table", "users")

fmt.Printf("用户ID: %v\n", err.Context["user_id"])
```

### 错误包装

```go
// 包装原始错误
originalErr := fmt.Errorf("连接被拒绝")
wrappedErr := errors.Wrap(originalErr, "NETWORK_ERROR", "网络连接失败")

fmt.Println(wrappedErr.Error())        // [NETWORK_ERROR] 网络连接失败
fmt.Println(wrappedErr.Unwrap().Error()) // 连接被拒绝
```

## 预定义错误类型

### 使用预定义错误类型

```go
// 使用预定义错误类型
err := errors.FromType(errors.NotFoundError)
fmt.Println(err.Error()) // [NOT_FOUND] Resource not found

// 自定义预定义错误类型
err = errors.FromType(errors.UnauthorizedError)
err.WithDetails("无效的API密钥")
fmt.Println(err.Error()) // [UNAUTHORIZED] Authentication required: 无效的API密钥
```

### 可用的预定义错误类型

- `InternalError`: 内部服务器错误
- `TimeoutError`: 超时错误
- `NotFoundError`: 资源未找到
- `UnauthorizedError`: 未授权
- `ForbiddenError`: 禁止访问
- `InvalidInputError`: 输入无效
- `MissingFieldError`: 缺少字段
- `NetworkError`: 网络错误
- `DatabaseError`: 数据库错误

## 构建器模式

```go
err := errors.NewBuilder().
    Code("VALIDATION_ERROR").
    Message("用户验证失败").
    Details("发生了多个验证错误").
    Severity(errors.SeverityHigh).
    Category(errors.CategoryValidation).
    Context("user_id", "12345").
    Context("validation_count", 3).
    Operation("create_user").
    Build()
```

## 便捷函数

```go
// 常用错误的便捷函数
notFoundErr := errors.NotFound("user")
invalidInputErr := errors.InvalidInput("email", "格式无效")
missingFieldErr := errors.MissingField("password")
timeoutErr := errors.Timeout("database_query", 30*time.Second)
```

## 验证功能

### 基本验证

```go
validator := errors.NewValidator()

email := "invalid-email"
password := "123"
age := -5

validator.Required("email", email).
    Email("email", email).
    Required("password", password).
    MinLength("password", password, 8).
    Required("age", age).
    Min("age", float64(age), 0)

if validator.HasErrors() {
    err := validator.GetError()
    fmt.Println("验证失败:", err.Error())
}
```

### 可用的验证方法

- `Required(field, value)`: 必填验证
- `MinLength(field, value, min)`: 最小长度
- `MaxLength(field, value, max)`: 最大长度
- `Email(field, value)`: 邮箱格式
- `URL(field, value)`: URL 格式
- `Regex(field, value, pattern)`: 正则表达式
- `Numeric(field, value)`: 数字格式
- `Integer(field, value)`: 整数格式
- `Min(field, value, min)`: 最小值
- `Max(field, value, max)`: 最大值
- `Range(field, value, min, max)`: 范围验证
- `In(field, value, allowed)`: 枚举验证
- `Date(field, value, layout)`: 日期格式
- `Custom(field, value, rule, func, message)`: 自定义验证

### 自定义验证

```go
validator := errors.NewValidator()

isValidUsername := func(value interface{}) bool {
    username, ok := value.(string)
    if !ok {
        return false
    }
    // 用户名必须是字母数字，3-20个字符
    if len(username) < 3 || len(username) > 20 {
        return false
    }
    for _, char := range username {
        if !((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9')) {
            return false
        }
    }
    return true
}

username := "user@123"
validator.Custom("username", username, "valid_username", isValidUsername, "用户名必须是字母数字，3-20个字符")
```

## 工具函数

### 错误检查和提取

```go
err := errors.FromType(errors.DatabaseError)

// 检查错误属性
code := errors.GetCode(err)           // 获取错误码
severity := errors.GetSeverity(err)   // 获取严重级别
category := errors.GetCategory(err)   // 获取错误类别
retryable := errors.IsRetryable(err)  // 是否可重试
critical := errors.IsCritical(err)    // 是否严重

// 获取上下文信息
value, exists := errors.GetContext(err, "user_id")
allContext := errors.GetAllContext(err)
```

### 错误链操作

```go
// 获取错误链
chain := errors.Chain(err)
rootErr := errors.Root(err)

// 检查错误类型
if errors.Is(err, "NETWORK_ERROR") {
    // 处理网络错误
}

// 提取特定错误类型
var customErr *errors.Error
if errors.As(err, &customErr) {
    // 使用自定义错误
}
```

### 错误格式化

```go
// 不同格式的错误输出
shortFormat := errors.Format(err, "short")     // 简短格式
detailedFormat := errors.Format(err, "detailed") // 详细格式
jsonFormat := errors.Format(err, "json")       // JSON格式
```

### 错误合并

```go
err1 := errors.InvalidInput("email", "格式无效")
err2 := errors.MissingField("password")
err3 := errors.InvalidInput("age", "必须为正数")

// 合并多个错误
mergedErr := errors.Merge(err1, err2, err3)
fmt.Println(mergedErr.Error())
```

## 错误严重级别和类别

### 严重级别

- `SeverityLow`: 低
- `SeverityMedium`: 中
- `SeverityHigh`: 高
- `SeverityCritical`: 严重

### 错误类别

- `CategorySystem`: 系统错误
- `CategoryAuth`: 认证错误
- `CategoryValidation`: 验证错误
- `CategoryNetwork`: 网络错误
- `CategoryDatabase`: 数据库错误
- `CategoryBusiness`: 业务逻辑错误
- `CategoryExternal`: 外部服务错误

## 最佳实践

### 1. 使用有意义的错误码

```go
// 好的做法
err := errors.New("USER_EMAIL_ALREADY_EXISTS", "用户邮箱已存在")

// 避免
err := errors.New("ERROR_001", "错误")
```

### 2. 添加相关上下文

```go
err := errors.New("PAYMENT_FAILED", "支付失败")
err.WithContext("user_id", userID)
err.WithContext("amount", amount)
err.WithContext("payment_method", "credit_card")
```

### 3. 使用适当的严重级别

```go
// 严重错误
criticalErr := errors.NewBuilder().
    Code("DATABASE_CONNECTION_LOST").
    Message("数据库连接丢失").
    Severity(errors.SeverityCritical).
    Build()

// 一般错误
validationErr := errors.NewBuilder().
    Code("INVALID_EMAIL").
    Message("邮箱格式无效").
    Severity(errors.SeverityMedium).
    Build()
```

### 4. 错误包装保持信息

```go
func processUser(userID string) error {
    user, err := getUserFromDB(userID)
    if err != nil {
        return errors.Wrap(err, "USER_FETCH_FAILED", "获取用户信息失败").
            WithContext("user_id", userID)
    }
    // 处理用户...
    return nil
}
```

### 5. 日志记录结构化信息

```go
err := errors.NewBuilder().
    Code("ORDER_PROCESSING_FAILED").
    Message("订单处理失败").
    UserID("user123").
    RequestID("req456").
    Operation("process_order").
    Context("order_id", "order789").
    Build()

// 结构化日志
log.Printf("错误详情: %s", errors.Format(err, "json"))
```

## 与标准库集成

这个包与 Go 标准库的 `errors` 包完全兼容：

```go
import (
    "errors" as stderrors
    "github.com/iwen-conf/utils-pkg/errors"
)

// 可以包装标准错误
stdErr := stderrors.New("标准错误")
customErr := errors.Wrap(stdErr, "WRAPPED_ERROR", "包装的错误")

// 使用标准库函数
if stderrors.Is(customErr, stdErr) {
    // 处理错误
}
```

## 性能考虑

- 错误创建是轻量级的，但避免在热路径中创建大量错误
- 上下文信息使用 `map[string]interface{}`，避免存储大对象
- 错误链不应过深，建议不超过 10 层
- 验证器可以重用，但不是线程安全的

## 线程安全

- `Error` 结构体在创建后是不可变的（除了通过 `WithXXX` 方法修改）
- `Validator` 不是线程安全的，每个 goroutine 应使用独立的实例
- 工具函数都是线程安全的

## 示例项目

查看 `examples_test.go` 文件获取更多详细的使用示例。

## 贡献

欢迎提交 Issue 和 Pull Request 来改进这个包。

## 许可证

本项目采用 MIT 许可证。
