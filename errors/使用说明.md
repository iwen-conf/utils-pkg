# 错误处理系统使用说明

## 概述

errors模块是一个通用、灵活的错误处理系统，专为Go语言设计。它提供了完整的错误创建、包装、分类、处理和格式化功能，适用于各种业务场景。

## 核心特性

- 🎯 **通用性**: 不再局限于特定业务场景
- 🔧 **可扩展**: 支持动态错误码注册和管理
- 📊 **分类系统**: 自动错误分类（系统、客户端、业务）
- 🏗️ **构建器模式**: 链式调用创建复杂错误
- 🎨 **格式化器**: 多种错误输出格式
- ⚡ **高性能**: 线程安全，支持高并发
- 📚 **完整API**: 丰富的错误处理工具函数

## 快速开始

### 基础错误创建

```go
import "github.com/iwen-conf/utils-pkg/errors"

// 创建简单错误
err := errors.New("USER001", "用户不存在")

// 创建带详细信息的错误
err = errors.NewWithDetails("DATA001", "数据验证失败", "输入参数不符合要求")

// 包装现有错误
dbErr := fmt.Errorf("数据库连接失败")
err = errors.Wrap(dbErr, "DB001", "数据库操作异常")
```

### 错误码注册

```go
// 注册单个错误码
errors.RegisterErrorCode("CUSTOM001", "自定义业务错误")

// 批量注册错误码
errors.RegisterErrorCodes(map[string]string{
    "AUTH001": "认证失败",
    "AUTH002": "权限不足",
    "AUTH003": "令牌过期",
})

// 注册错误码前缀分类
errors.RegisterErrorPrefix("AUTH", "authentication")
errors.RegisterErrorPrefix("USER", "user_management")
```

## 详细功能

### 1. 错误结构体

```go
type Error struct {
    Code       string                 // 错误码
    Message    string                 // 错误消息
    Details    string                 // 详细错误信息
    Timestamp  time.Time              // 错误发生时间
    Context    map[string]interface{} // 上下文信息
    Original   error                  // 原始错误
    StackTrace []StackFrame           // 堆栈跟踪
}
```

### 2. 错误构建器

使用构建器模式创建复杂的错误：

```go
err := errors.NewBuilder().
    Code("USER001").
    Message("用户不存在").
    Details("用户ID无效").
    Context("user_id", "user123").
    Context("request_id", "req_456").
    Context("timestamp", time.Now().Unix()).
    Build()
```

### 3. 错误分类系统

系统自动根据错误码前缀进行分类：

```go
// 根据错误码判断类型
if errors.IsSystemError("5000") {
    // 系统级错误
}

if errors.IsClientError("4001") {
    // 客户端错误
}

if errors.IsBusinessErrorCode("6001") {
    // 业务错误
}

// 获取错误分类
category := errors.GetCategoryByCode("5000") // 返回 "server"
```

### 4. 错误格式化器

支持多种错误输出格式：

```go
// 默认格式化器
formatted := errors.FormatError(err)
// 输出: Code: USER001 | Message: 用户不存在 | Details: 用户ID无效

// JSON格式化器
errors.SetDefaultFormatter(&errors.JSONFormatter{})
formatted = errors.FormatError(err)
// 输出: {"code":"USER001","message":"用户不存在","details":"用户ID无效"}

// 自定义格式化器
type CustomFormatter struct{}

func (f *CustomFormatter) Format(err *errors.Error) string {
    return fmt.Sprintf("[%s] %s", err.Code, err.Message)
}

errors.SetDefaultFormatter(&CustomFormatter{})
```

### 5. 错误处理器链

支持链式错误处理：

```go
handlerChain := errors.NewHandlerChain().
    Add(func(err *errors.Error) error {
        // 记录错误日志
        log.Printf("Error: %s", err.Error())
        return nil
    }).
    Add(func(err *errors.Error) error {
        // 发送错误通知
        if errors.IsSystemError(err.Code) {
            sendAlert(err)
        }
        return nil
    }).
    Add(func(err *errors.Error) error {
        // 错误统计
        incrementErrorCounter(err.Code)
        return nil
    })

// 处理错误
handlerChain.Handle(err)
```

### 6. 错误聚合器

收集和处理多个错误：

```go
aggregator := errors.NewAggregator()

// 收集多个错误
aggregator.Add(err1)
aggregator.Add(err2)
aggregator.Add(err3)

if aggregator.HasErrors() {
    // 处理聚合的错误
    for _, err := range aggregator.Errors() {
        fmt.Printf("Error: %s\n", err.Error())
    }
    
    // 获取聚合错误的字符串表示
    fmt.Println(aggregator.Error())
}

// 清空聚合器
aggregator.Clear()
```

### 7. 错误判断工具

```go
// 检查是否为业务错误
if errors.IsBusinessError(err) {
    // 处理业务错误
}

// 获取业务错误
if businessErr := errors.GetBusinessError(err); businessErr != nil {
    // 使用业务错误
}

// 检查错误码
if errors.HasCode(err, "USER001") {
    // 处理特定错误码
}

// 获取错误信息
code := errors.GetErrorCode(err)
message := errors.GetErrorMessage(err)
details := errors.GetErrorDetails(err)
context := errors.GetErrorContext(err)
```

### 8. 堆栈跟踪

```go
// 全局开启堆栈跟踪
errors.SetEnableStackTrace(true)

// 创建带堆栈跟踪的错误
err := errors.NewWithStack("ERROR001", "发生错误")

// 包装错误时添加堆栈跟踪
err = errors.WrapWithStack(originalErr, "ERROR002", "包装错误")
```

## 预定义错误码

系统提供了一套通用的错误码体系：

### 客户端错误 (4xxx)
- `4000`: 请求错误
- `4001`: 未授权
- `4003`: 禁止访问
- `4004`: 资源不存在
- `4005`: 方法不允许
- `4008`: 请求超时
- `4009`: 资源冲突
- `4029`: 请求过于频繁

### 服务端错误 (5xxx)
- `5000`: 内部服务器错误
- `5001`: 功能未实现
- `5002`: 网关错误
- `5003`: 服务不可用
- `5004`: 网关超时

### 业务错误 (6xxx)
- `6000`: 业务错误
- `6001`: 数据验证错误
- `6002`: 数据不存在
- `6003`: 数据已存在
- `6004`: 操作失败

## 最佳实践

### 1. 错误码命名规范

```go
// 推荐：使用有意义的错误码
errors.RegisterErrorCode("USER_NOT_FOUND", "用户不存在")
errors.RegisterErrorCode("INVALID_PASSWORD", "密码无效")

// 不推荐：使用无意义的数字
errors.RegisterErrorCode("1001", "用户不存在")
```

### 2. 错误上下文信息

```go
err := errors.NewBuilder().
    Code("USER001").
    Message("用户不存在").
    Context("user_id", userID).
    Context("request_id", requestID).
    Context("timestamp", time.Now().Unix()).
    Build()
```

### 3. 错误处理策略

```go
// 根据错误类型采用不同策略
switch errors.GetCategoryByCode(err.Code) {
case "client":
    // 客户端错误，返回给用户
    return http.StatusBadRequest, err
case "server":
    // 服务端错误，记录日志并返回通用错误
    log.Printf("Server error: %v", err)
    return http.StatusInternalServerError, errors.New("5000", "内部服务器错误")
case "business":
    // 业务错误，返回具体错误信息
    return http.StatusUnprocessableEntity, err
default:
    // 未知错误，记录日志
    log.Printf("Unknown error: %v", err)
    return http.StatusInternalServerError, errors.New("5000", "内部服务器错误")
}
```

### 4. 错误聚合处理

```go
// 在批量操作中收集错误
aggregator := errors.NewAggregator()

for _, item := range items {
    if err := processItem(item); err != nil {
        aggregator.Add(err)
    }
}

if aggregator.HasErrors() {
    // 处理所有错误
    log.Printf("Batch operation failed with %d errors", len(aggregator.Errors()))
    return aggregator.Error()
}
```

## 性能考虑

- 错误码注册使用读写锁，支持高并发
- 错误构建器复用内存，减少GC压力
- 格式化器支持缓存，提高重复格式化性能
- 堆栈跟踪可选开启，避免性能开销

## 测试

模块包含完整的测试覆盖：

```bash
# 运行所有测试
go test ./...

# 运行基准测试
go test -bench=. ./...

# 运行测试并显示覆盖率
go test -cover ./...
```

## 总结

errors模块提供了一个完整、灵活、高性能的错误处理解决方案。它不再局限于特定业务场景，可以适用于各种Go项目，帮助开发者构建健壮的错误处理系统。
